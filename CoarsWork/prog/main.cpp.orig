#include <iostream>
#include <vector>
#include "Objects.hpp"
#include "graphics.h"

#define POS2CORD(x) 100*x

using namespace std;

vector <Robot *> Robots; // глобальный вектор с роботами
vector <Programm *> Programms; // глобальный вектор с программами

void clearWin() {
   putimage(0, 0, loadBMP("inteface.bmp"), COPY_PUT);
}

void put_text(string text_task) {
   setbkcolor(NO_COLOR);
   setcolor(BLACK);
   const char *cstr = text_task.c_str();
   settextstyle(GOTHIC_FONT, HORIZ_DIR, 12);
   outtextxy(510, 60, cstr);
}

void reDraw(string text_task) { // перерисовка поля
   clearWin(); // отрисовываем задний фон
   // выводим текст задания
   put_text(text_task);
   // Отрисовываем программмы и роботов
   for (int i = 0; i < Programms.size(); i++) {
      Programms[i]->draw();
      setcolor(BLACK);
      int heightB = 125;
      rectangle(i*heightB,500, i*heightB+122, 549);
      setfillstyle(SOLID_FILL, Programms[i]->get_col());
      bar(i*heightB,500, i*heightB+122, 549);
   }
   for (int i = 0; i < Robots.size(); i++)
      Robots[i]->draw();
}

void highlightCell(position current_cell) { // выделение ячейки
   setlinestyle(0, 1, 3);
   setcolor(YELLOW);
   rectangle(POS2CORD(current_cell.x), POS2CORD(current_cell.y), POS2CORD(current_cell.x+100), POS2CORD(current_cell.y+100));
}


void drawCurrectProg(int n_currect_com, position current_cell) {
   clearWin();
   highlightCell(current_cell);
   Programms[n_currect_com]->draw();
   for (int i = 0; i < Robots.size(); i++)
      if (Robots[i]->get_color() == Programms[n_currect_com]->get_col()) {
         setcolor(BLACK);
         int heightB = 125;
         rectangle(n_currect_com*heightB,500, n_currect_com*heightB+122, 549);
         setfillstyle(SOLID_FILL, Programms[n_currect_com]->get_col());
         bar(n_currect_com*heightB,500, n_currect_com*heightB+122, 549);
      }
}


int n_currect_com = 0;

int main() {
   initwindow(800, 550, "Программа для обучения программированию");
   clearWin();

   position current_cell(0, 0); // позиция текущей клетки

   Field field(WIDTH_I, HEIGHT_J); //создание объекта поля

   Task task("tast_list.txt");

   task.initialize(field, Robots, Programms); //инициализация роботов и программ
   string text_task = task.get_text_task(); // получение текста задания
   task.prepare_field(field); // подготовка поля с расстановкой объектов
   highlightCell(current_cell); // отображение текущей ячейки
   while (1) {

      //выбор текущей клетки
      switch (getch(kbhit())) {
      case KEY_UP:
         reDraw(text_task);
         current_cell.y += (current_cell.y == 0) ? 0 : -1;
         highlightCell(current_cell);
         break;
      case KEY_DOWN:
         reDraw(text_task);
         current_cell.y += (current_cell.y == HEIGHT_J-1) ? 0 : 1;
         highlightCell(current_cell);
         break;
      case KEY_LEFT:
         reDraw(text_task);
         current_cell.x += (current_cell.x == 0) ? 0 : -1;
         highlightCell(current_cell);
         break;
      case KEY_RIGHT:
         reDraw(text_task);
         current_cell.x += (current_cell.x == WIDTH_I-1) ? 0 : 1;
         highlightCell(current_cell);
         break;

      // отображение программ только определённого цвета
      case '1':
         cout << "Выбрана программа 1"<<endl;
         n_currect_com = 0;
         put_text(text_task);
         drawCurrectProg(n_currect_com, current_cell);
         break;
      case '2':
         if (Programms.size() <2)
            break;
         cout << "Выбрана программа 2"<<endl;
         n_currect_com = 1;
         drawCurrectProg(n_currect_com, current_cell);
                  put_text(text_task);

         break;
      case '3':
         if (Programms.size() <3)
            break;
         cout << "Выбрана программа 3"<<endl;
         n_currect_com = 2;
         drawCurrectProg(n_currect_com, current_cell);
         put_text(text_task);
         break;
      case '4':
         if (Programms.size() <4)
            break;
         cout << "Выбрана программа 4"<<endl;
         n_currect_com = 3;
         drawCurrectProg(n_currect_com, current_cell);
         put_text(text_task);
         break;
      //выбор комманды
      case KEY_ENTER:

         break;
      // удаление объкта
      case KEY_DELETE:

         break;
      //отмена удаления
      case KEY_BACKSPACE:

         break;
      //закрытие
      case KEY_ESC:
         closegraph();
         return 0;
      }
   }
}