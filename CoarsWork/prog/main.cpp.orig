#include "Objects.hpp"

using namespace std;

vector <Robot *> Robots; // глобальный вектор с роботами
vector <Programm *> Programms; // глобальный вектор с программами

Field field(WIDTH_I, HEIGHT_J); //создание объекта поля

//очистка окна
void clearWin() {
   putimage(0, 0, loadBMP("inteface.bmp"), COPY_PUT);
}

//вставка текста задания
void put_text(string text_task) {
   setbkcolor(NO_COLOR);
   setcolor(BLACK);
   const char *cstr = text_task.c_str();
   settextstyle(GOTHIC_FONT, HORIZ_DIR, 12);
   outtextxy(510, 60, cstr);
}

//отрисовка индикатора выбранной программы в нижней панели
void drawBarCurrectProg(int i) {
   setcolor(BLACK);
   int heightB = 125;
   rectangle(i*heightB,500, i*heightB+122, 549);
   setfillstyle(SOLID_FILL, Programms[i]->get_col());
   bar(i*heightB,501, i*heightB+122, 549);
}

// перерисовка всех элементов во время выполнения программы роботами
void reDraw(string text_task) {
   clearWin(); // отрисовываем задний фон
   // выводим текст задания
   put_text(text_task);
   //прорисовка объектов на поле
   field.draw();
   // Отрисовываем программмы и роботов
   for (int i = 0; i < Programms.size(); i++) {
      Programms[i]->draw();
      drawBarCurrectProg(i);
   }
   for (int i = 0; i < Robots.size(); i++)
      Robots[i]->draw();
}

// выделение ячейки
void highlightCell(position current_cell) {
   setlinestyle(0, 1, 3);
   setcolor(YELLOW);
   rectangle(100*current_cell.x, 100*current_cell.y, 100*current_cell.x+100, 100*current_cell.y+100);
}

//отрисока текущей программы
void drawCurrectProg(int n_currect_com, position current_cell) {
   clearWin();
   Programms[n_currect_com]->draw();
   field.draw();
   for (int i = 0; i < Robots.size(); i++)
      if (Robots[i]->get_color() == Programms[n_currect_com]->get_col()) {
         Robots[i]->draw();
         drawBarCurrectProg(n_currect_com);
      }
}

int n_currect_com = 0; //номер текущей программы

int main() {
   initwindow(800, 550, "Программа для обучения программированию");
   clearWin();

   position current_cell(0, 0); // позиция текущей клетки

   Task task("tast_list.txt"); // сохранение названия файла с заданием
   task.prepare_field(field); // подготовка поля с расстановкой объектов
restart:
   task.initialize(field, Robots, Programms); //инициализация роботов и программ
   string text_task = task.get_text_task(); // получение текста задания
   highlightCell(current_cell); // отображение текущей ячейки
   while (1) {
      //выбор текущей клетки
      switch (getch()) {
      case KEY_UP: {
            drawCurrectProg(n_currect_com, current_cell);
            current_cell.y += (current_cell.y == 0) ? 0 : -1;
            highlightCell(current_cell);
            break;
         }
      case KEY_DOWN: {
            drawCurrectProg(n_currect_com, current_cell);
            current_cell.y += (current_cell.y == HEIGHT_J-1) ? 0 : 1;
            highlightCell(current_cell);
            break;
         }
      case KEY_LEFT: {
            drawCurrectProg(n_currect_com, current_cell);
            current_cell.x += (current_cell.x == 0) ? 0 : -1;
            highlightCell(current_cell);
            break;
         }
      case KEY_RIGHT: {
            drawCurrectProg(n_currect_com, current_cell);
            current_cell.x += (current_cell.x == WIDTH_I-1) ? 0 : 1;
            highlightCell(current_cell);
            break;
         }
      // отображение программ только определённого цвета
      case '1': {
            cout << "Выбрана программа 1"<<endl;
            n_currect_com = 0;
            drawCurrectProg(n_currect_com, current_cell);
            put_text(text_task);
            break;
         }
      case '2':
         if (Programms.size() <2)
            break;
         cout << "Выбрана программа 2"<<endl;
         n_currect_com = 1;
         drawCurrectProg(n_currect_com, current_cell);
         put_text(text_task);
         break;
      case '3': {
            if (Programms.size() <3)
               break;
            cout << "Выбрана программа 3"<<endl;
            n_currect_com = 2;
            drawCurrectProg(n_currect_com, current_cell);
            put_text(text_task);
            break;
         }
      case '4': {
            if (Programms.size() <4)
               break;
            cout << "Выбрана программа 4"<<endl;
            n_currect_com = 3;
            drawCurrectProg(n_currect_com, current_cell);
            put_text(text_task);
            break;
         }
      //выбор комманды
      case KEY_ENTER: {
            Command *com = Programms[n_currect_com]->select(current_cell);
            if (com != nullptr && com->get_allow_pos()) {
               while (1) {
                  switch (getch()) {
                  case KEY_UP: {
                        current_cell.y += (current_cell.y == 0) ? 0 : -1;
                        com->set_pos(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                  case KEY_DOWN: {
                        current_cell.y += (current_cell.y == HEIGHT_J-1) ? 0 : 1;
                        com->set_pos(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                  case KEY_LEFT: {
                        current_cell.x += (current_cell.x == 0) ? 0 : -1;
                        com->set_pos(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                  case KEY_RIGHT: {
                        current_cell.x += (current_cell.x == WIDTH_I-1) ? 0 : 1;
                        com->set_pos(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                     case KEY_ENTER:{
                        
                     }
                  }
               }
               
               else {
                  for (int i = 0; i < Robots.size(); i++) {
                     if (current_cell == Robots[i]->get_cordinat()) {
               while (1) {
                  switch (getch()) {
                  case KEY_UP: {
                        current_cell.y += (current_cell.y == 0) ? 0 : -1;
                        Robots[i]->get_cordinat(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                  case KEY_DOWN: {
                        current_cell.y += (current_cell.y == HEIGHT_J-1) ? 0 : 1;
                        Robots[i]->get_cordinat(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                  case KEY_LEFT: {
                        current_cell.x += (current_cell.x == 0) ? 0 : -1;
                        Robots[i]->get_cordinat(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                  case KEY_RIGHT: {
                        current_cell.x += (current_cell.x == WIDTH_I-1) ? 0 : 1;
                        Robots[i]->get_cordinat(current_cell);
                        drawCurrectProg(n_currect_com, current_cell);
                        highlightCell(current_cell);
                        break;
                     }
                     case KEY_ENTER:{
                        
                     }
                  }
               }
                     }
                  }
               }
               break;
            }
         // удаление объкта
         case KEY_DELETE: {
               Command *com = Programms[n_currect_com]->select(current_cell);
               if (com != nullptr) {
                  Programms[n_currect_com]->delete_com(com);
                  drawCurrectProg(n_currect_com, current_cell);
               }
               break;
            }
         // запуск программы
         case KEY_TAB: {

               for (int i = 0; i < Robots.size(); i++) {
                  if (Robots[i]->is_crash(Robots)) {
                     put_text("Столкновение!");
                     delay(1000);
                     clearWin();
                     Robots.clear();
                     Programms.clear();
                     goto restart;
                  }
               }
               // перемещение роботов
               for (int i = 0; i < Robots.size(); i++) {
                  position new_pos = Robots[i]->get_cordinat();
                  new_pos.x += Robots[i]->get_direction().x;
                  new_pos.y += Robots[i]->get_direction().y;
                  Robots[i]->set_cordinat(new_pos);
                  Robots[i]->draw();
                  reDraw(text_task);
               }

               break;
            }
         // возврат в изначальное состояние
         case KEY_BACKSPACE: {
               Robots.clear();
               Programms.clear();
               task.initialize(field, Robots, Programms);
               drawCurrectProg(n_currect_com, current_cell);
               highlightCell(current_cell);
            }
            break;
         //закрытие
         case KEY_ESC:
            closegraph();
            return 0;
         }
      }
   }